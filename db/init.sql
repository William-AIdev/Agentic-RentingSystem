drop extension if exists "pg_net";

create extension if not exists "btree_gist" with schema "public";

create type "public"."order_status" as enum ('reserved', 'paid', 'shipped', 'overdue', 'successful', 'canceled');


  create table "public"."catalog" (
    "sku" text not null,
    "color" text not null,
    "size" text not null
      );



  create table "public"."orders" (
    "id" bigint generated by default as identity not null,
    "order_id" text not null,
    "user_name" text not null,
    "user_wechat" text not null,
    "sku" text not null,
    "start_at" timestamp with time zone not null,
    "end_at" timestamp with time zone not null,
    "buffer_hours" integer not null default 3,
    "occupied" tstzrange not null,
    "status" public.order_status not null default 'reserved'::public.order_status,
    "locker_code" text default ''::text,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now()
      );


CREATE UNIQUE INDEX catalog_pkey ON public.catalog USING btree (sku);

select 1;
-- CREATE INDEX orders_no_overlap_per_sku ON public.orders USING gist (sku, occupied) WHERE (status = ANY (ARRAY['reserved'::public.order_status, 'paid'::public.order_status, 'shipped'::public.order_status, 'overdue'::public.order_status]));

CREATE UNIQUE INDEX orders_order_id_key ON public.orders USING btree (order_id);

CREATE UNIQUE INDEX orders_pkey ON public.orders USING btree (id);

alter table "public"."catalog" add constraint "catalog_pkey" PRIMARY KEY using index "catalog_pkey";

alter table "public"."orders" add constraint "orders_pkey" PRIMARY KEY using index "orders_pkey";

alter table "public"."orders" add constraint "orders_no_overlap_per_sku" EXCLUDE USING gist (sku WITH =, occupied WITH &&) WHERE ((status = ANY (ARRAY['reserved'::public.order_status, 'paid'::public.order_status, 'shipped'::public.order_status, 'overdue'::public.order_status])));

alter table "public"."orders" add constraint "orders_order_id_key" UNIQUE using index "orders_order_id_key";

alter table "public"."orders" add constraint "orders_sku_fk" FOREIGN KEY (sku) REFERENCES public.catalog(sku) not valid;

alter table "public"."orders" validate constraint "orders_sku_fk";

alter table "public"."orders" add constraint "orders_status_lockcode" CHECK (((status <> ALL (ARRAY['shipped'::public.order_status, 'overdue'::public.order_status, 'successful'::public.order_status])) OR (locker_code IS NOT NULL))) not valid;

alter table "public"."orders" validate constraint "orders_status_lockcode";

alter table "public"."orders" add constraint "shipped_requires_locker_code" CHECK (((status <> 'shipped'::public.order_status) OR (locker_code IS NOT NULL))) not valid;

alter table "public"."orders" validate constraint "shipped_requires_locker_code";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.orders_set_derived_fields()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
begin
  -- occupied = [start_at, end_at + bufferHours)
  new.occupied := tstzrange(
    new.start_at,
    new.end_at + make_interval(hours => new.buffer_hours),
    '[)'
  );

  new.updated_at := now();

  return new;
end;
$function$
;

grant delete on table "public"."catalog" to "anon";

grant insert on table "public"."catalog" to "anon";

grant references on table "public"."catalog" to "anon";

grant select on table "public"."catalog" to "anon";

grant trigger on table "public"."catalog" to "anon";

grant truncate on table "public"."catalog" to "anon";

grant update on table "public"."catalog" to "anon";

grant delete on table "public"."catalog" to "authenticated";

grant insert on table "public"."catalog" to "authenticated";

grant references on table "public"."catalog" to "authenticated";

grant select on table "public"."catalog" to "authenticated";

grant trigger on table "public"."catalog" to "authenticated";

grant truncate on table "public"."catalog" to "authenticated";

grant update on table "public"."catalog" to "authenticated";

grant delete on table "public"."catalog" to "service_role";

grant insert on table "public"."catalog" to "service_role";

grant references on table "public"."catalog" to "service_role";

grant select on table "public"."catalog" to "service_role";

grant trigger on table "public"."catalog" to "service_role";

grant truncate on table "public"."catalog" to "service_role";

grant update on table "public"."catalog" to "service_role";

grant delete on table "public"."orders" to "anon";

grant insert on table "public"."orders" to "anon";

grant references on table "public"."orders" to "anon";

grant select on table "public"."orders" to "anon";

grant trigger on table "public"."orders" to "anon";

grant truncate on table "public"."orders" to "anon";

grant update on table "public"."orders" to "anon";

grant delete on table "public"."orders" to "authenticated";

grant insert on table "public"."orders" to "authenticated";

grant references on table "public"."orders" to "authenticated";

grant select on table "public"."orders" to "authenticated";

grant trigger on table "public"."orders" to "authenticated";

grant truncate on table "public"."orders" to "authenticated";

grant update on table "public"."orders" to "authenticated";

grant delete on table "public"."orders" to "service_role";

grant insert on table "public"."orders" to "service_role";

grant references on table "public"."orders" to "service_role";

grant select on table "public"."orders" to "service_role";

grant trigger on table "public"."orders" to "service_role";

grant truncate on table "public"."orders" to "service_role";

grant update on table "public"."orders" to "service_role";

CREATE TRIGGER trg_orders_set_derived_fields BEFORE INSERT OR UPDATE OF start_at, end_at, buffer_hours ON public.orders FOR EACH ROW EXECUTE FUNCTION public.orders_set_derived_fields();


